---
title: 'String Approximation Operator'
sidebarTitle: 'String Approximation'
description: 'The String Approximation Operator allows to run queries with partial strings to match properties in nodes'
---

# ğŸ” String Approximation Operator (`~=`)

TuringDB extends the standard Cypher query language with an intuitive and **efficient approximate string matching operator**: `~=`. This feature is ideal for exploring knowledge graphs, especially when dealing with noisy data, ambiguous labels, or unknown naming conventions.

## ğŸ§  What It Does

The `~=` operator allows you to query **string properties** on nodes or edges **without requiring exact matches** or complex regular expressions.

Instead of:

```sql
MATCH (n{name="APOE-4"}) RETURN n
```

You can write:

```sql
MATCH (n{name~="apoe"}) RETURN n
```

This will return *all nodes where the property `name` is approximately related to "apoe"*.

## ğŸ“¦ Why It's Useful

- âœ… **No regex required** â€” More human-friendly and readable
- âš¡ **Faster than regex** â€” Avoids index-bypass performance issues seen in Neo4J
    
    [Source](https://stackoverflow.com/questions/31660948/neo4j-count-very-slow)
    
- ğŸ” **Designed for discovery** â€” Perfect for exploratory search, fuzzy graph lookups, or biomedical graph use cases

## ğŸ“„ Example 1: Matching Biological Entities

Given nodes:

```sql
(node:...{id:0, ..., name:"APOE-4 [extracellular]", ...})
(node:...{id:1, ..., name:"APOE-4", ...})
(node:...{id:2, ..., name:"APOE-4 [intracellular]", ...})
```

Query:

```sql
MATCH (n{name~="apoe"}) RETURN n
```

Results:

Match

```sql
APOE-4 [extracellular]
```

```sql
APOE-4
```

```sql
APOE-4 [intracellular]
```

âœ… All relevant nodes returned using **only a single word** â€” `apoe`.


## ğŸ“„ Example 2: Prefix Word Matching

Given nodes:

```sql
(node{id:1, desc:"play"})
(node{id:2, desc:"playful"})
(node{id:3, desc:"playfully"})
(node{id:4, desc:"pl"})
(node{id:5, desc:"plays"})
```

Query:

```sql
MATCH (n{desc~="play"}) RETURN n.id
```

Results:

```
id
---
1
2
3
5
```

- âœ… `play`, `playful`, `playfully`, and `plays` all match
- âŒ `pl` does **not** match (`pl` only matches 50% of "play" â€” below threshold)


## âš™ï¸ How It Works

- Matching is done using **word-level prefix matching**
- A **â€œwordâ€** is any substring separated by whitespace
- **Only alphanumeric characters are used** â€” symbols are stripped before matching
- The **minimum match threshold is 75%** of the query string's length

### Match Example

- Query: `"play"` (length: 4)
- Minimum prefix: `"pla"` (75% of 4 = 3)
- `playful` âœ…
- `plays` âœ…
- `pl` âŒ


## ğŸ”¬ Use Cases

- Searching biomedical knowledge graphs (e.g., proteins, genes, diseases)
- Fuzzy matching in messy datasets
- Finding similar named entities (e.g., `APOE-4`, `APOE`, `APOE2`)
- Natural language matching for agentic workflows or LLM graph queries


## ğŸ“ Syntax Summary

```sql
MATCH (n{property~="search_term"}) RETURN n
```

- Works with **any node or edge property** that is a string
- Case-insensitive
- No regex or wildcards needed

## ğŸš§ Limitations

- Works only on **string properties**
- Currently supports **prefix word-level matching only**
- Does **not support substring** or typo-tolerant matching yet (planned roadmap)


## ğŸ”­ Future Improvements - Roadmap

TuringDB may extend `~=` in the future with:

- Fuzzy edit-distance matching (e.g., `levenshtein`)
- Optional configuration for matching thresholds
- Substring or suffix modes

Stay tuned!